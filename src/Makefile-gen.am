include $(top_srcdir)/m4-repo/autotroll.mk

BACKENDS = @BACKENDS@

# start with building nothing and add more targets below
SUBDIRS =
EXTRA_PROGRAMS =
TESTS =
bin_PROGRAMS =
bin_SCRIPTS =
nodist_bin_SCRIPTS =
libexec_PROGRAMS =
libexec_SCRIPTS =
nobase_dist_template_DATA =
CLEANFILES =
BUILT_SOURCES =

service_in_files = org.syncevolution.service.in
if COND_DBUS
servicedir = $(DBUS_SERVICES_DIR)
service_DATA = $(service_in_files:.service.in=.service)
$(service_DATA): $(service_in_files) Makefile
	@sed -e "s|\@libexecdir\@|$(libexecdir)|" $< > $@
SUBDIRS += gdbus
endif
if ENABLE_GNOME_BLUETOOTH_PANEL
SUBDIRS += gnome-bluetooth
endif
if COND_CORE
SUBDIRS += $(SYNTHESIS_SUBDIR) syncevo $(BACKENDS)
bin_PROGRAMS += syncevolution
bin_SCRIPTS += synccompare
nobase_dist_template_DATA += $(TEMPLATE_FILES)
else
SUBDIRS += $(SYNTHESIS_SUBDIR_INCLUDES)
endif
SUBDIRS += dbus
if COND_GUI
SUBDIRS += gtk-ui
else
endif

DIST_SUBDIRS = gdbus dbus syncevo $(BACKENDS) gtk-ui gnome-bluetooth synthesis-includes

AM_CPPFLAGS = $(SUBDIRS:%=-I$(srcdir)/%) -I$(srcdir)/../test -I$(top_srcdir) $(BACKEND_CPPFLAGS)

DISTCLEANFILES += synccompare
CLEANFILES += libstdc++.a client-test $(CLIENT_LIB_TEST_FILES) \
	org.syncevolution.service \
    $(SYNCEVO_DBUS_SERVER_DESKTOP) $(SYNCEVO_DBUS_SERVER_SCRIPT)

SYNCEVO_DBUS_SERVER_SCRIPT = syncevo-dbus-server-startup.sh
SYNCEVO_DBUS_SERVER_SCRIPT_IN = $(SYNCEVO_DBUS_SERVER_SCRIPT).in

autostartdir = $(sysconfdir)/xdg/autostart
SYNCEVO_DBUS_SERVER_DESKTOP = syncevo-dbus-server.desktop
SYNCEVO_DBUS_SERVER_DESKTOP_IN = $(SYNCEVO_DBUS_SERVER_DESKTOP).in

if COND_DBUS
libexec_PROGRAMS += syncevo-dbus-server
nodist_bin_SCRIPTS += syncevo-http-server
libexec_SCRIPTS += $(SYNCEVO_DBUS_SERVER_SCRIPT)
$(libexec_SCRIPTS): $(SYNCEVO_DBUS_SERVER_SCRIPT_IN) Makefile
	@sed -e "s|\@libexecdir\@|$(libexecdir)|" $< > $@
autostart_DATA = $(SYNCEVO_DBUS_SERVER_DESKTOP)
$(autostart_DATA): $(SYNCEVO_DBUS_SERVER_DESKTOP_IN) Makefile
	@sed -e "s|\@libexecdir\@|$(libexecdir)|" $< > $@
endif
syncevo-http-server: $(srcdir)/../test/syncevo-http-server.py
	cp $< $@
CLEANFILES += syncevo-http-server

nodist_bin_SCRIPTS += syncevo-phone-config
syncevo-phone-config: $(srcdir)/../test/syncevo-phone-config.py
	cp $< $@
CLEANFILES += syncevo-phone-config

SYNCEVOLUTION_DEP =
if ENABLE_MODULES
else
SYNCEVOLUTION_LDADD += $(SYNCSOURCES)
SYNCEVOLUTION_DEP += $(SYNCSOURCES)
endif
EXTRA_DIST = shlibs.local Makefile-gen.am $(service_in_files) $(SYNCEVO_DBUS_SERVER_SCRIPT_IN) $(SYNCEVO_DBUS_SERVER_DESKTOP_IN)

TEMPLATE_FILES = @TEMPLATE_FILES@
templatedir = $(datadir)/syncevolution/

# synccompare is created by replacing its 'import Algorithm::Diff;'
# with a simplified copy of Diff.pm.
synccompare : ../test/Algorithm/Diff.pm ../test/synccompare.pl
	perl -e '$$diff = shift; open(DIFF, "<$$diff"); ($$_) = split(/__END__/, join("", <DIFF>)); s/\*import.*//m; s/require +Exporter;//; s/^#.*\n//mg; s/ +#.*\n//mg; $$diff = $$_;' -e 'while(<>) {' @MODIFY_SYNCCOMPARE@ -e 's/use +Algorithm::Diff;/"# embedded version of Algorithm::Diff follows, copyright by the original authors\n" . $$diff . "# end of embedded Algorithm::Diff\n"/e; print;}' $+ >$@
	chmod u+x $@

CORE_SOURCES =

# The files which register backends have to be compiled into
# "client-test" and "syncevolution" in order to pull in the
# code from the libs which implement the backends.
#
# Unit testing also goes there.
#
# When using modules the registration is done inside the
# module and the register file is unnecessary. However, they
# still need to be included in "make dist".
BACKEND_REGISTRIES = @BACKEND_REGISTRIES@
if ENABLE_MODULES
EXTRA_DIST += $(BACKEND_REGISTRIES)
else
CORE_SOURCES += $(BACKEND_REGISTRIES)
endif

CORE_CXXFLAGS = $(SYNTHESIS_CFLAGS)
CORE_LDADD = $(SYNCEVOLUTION_LDADD) syncevo/libsyncevolution.la $(GLIB_LIBS) $(GTHREAD_LIBS) $(GOBJECT_LIBS) $(LIBS)
CORE_DEP = $(SYNCEVOLUTION_DEP) syncevo/libsyncevolution.la $(SYNTHESIS_DEP)
CORE_LD_FLAGS = -Wl,-uSyncEvolution_Module_Version -Wl,--export-dynamic

# put link to static c++ library into current directory, needed if compiling with --enable-static-c++
libstdc++.a :
	path=`$(CXX) $(CORE_LDADD) $(LD_FLAGS) -print-file-name=libstdc++.a` && ln -s $$path .

syncevolution_SOURCES = \
	syncevolution.cpp \
	CmdlineSyncClient.h \
	CmdlineSyncClient.cpp \
	$(CORE_SOURCES)
if ENABLE_UNIT_TESTS
nodist_syncevolution_SOURCES = ../test/test.cpp
endif

# SYNCEVOLUTION_LDADD will be replaced with libsyncebook.la/libsyncecal.la/libsyncsqlite.la
# if linking statically against them, empty otherwise;
# either way this does not lead to a dependency on those libs - done explicitly
syncevolution_LDADD = $(CORE_LDADD) $(KEYRING_LIBS) $(KDE_KWALLET_LIBS)
if COND_DBUS
syncevolution_LDADD += gdbus/libgdbussyncevo.la
endif
syncevolution_LDFLAGS = $(CORE_LD_FLAGS) $(DBUS_LIBS)
syncevolution_CXXFLAGS = $(SYNCEVOLUTION_CXXFLAGS) $(CORE_CXXFLAGS) $(KEYRING_CFLAGS) -I$(srcdir)/gdbus $(DBUS_CFLAGS) $(KDE_KWALLET_CFLAGS)
syncevolution_DEPENDENCIES = $(EXTRA_LTLIBRARIES) $(CORE_DEP) # $(SYNTHESIS_DEP)

# rule which is only relevant when compiling Synthesis in subdirectory
#$(SYNTHESIS_LIB) : $(SYNTHESIS_SUBDIR)/all
#$(SYNTHESIS_SUBDIR)/% :
#	[ ! "$(SYNTHESIS_SUBDIR)" ] || ( cd ${@D} && $(MAKE) ${@F} )

# include Synthesis in distribution: package only files in git if using a git checkout
dist-hook:
	set -x; [ ! "$(SYNTHESIS_SUBDIR)" ] || \
	mkdir -p $(distdir)/synthesis && \
	if test -d "$(SYNTHESIS_SRC)/.git"; \
	then \
		( ( cd "$(SYNTHESIS_SRC)" && git archive HEAD ) | ( cd "$(distdir)/synthesis" && tar xf - && $$SHELL autogen.sh && rm -rf autom4te.cache ) ) && \
		( echo Creating ChangeLog && \
		  ( ( cd "$(SYNTHESIS_SRC)" && \
		      echo '# Generated by configure.  Do no edit.' && \
		      githash=`git show-ref --head --hash | head -1` && \
		      echo "# git revision $$githash"  && \
		      echo "# git tag `git describe --tags $$githash`" && \
		      echo && \
		      "$(top_srcdir)/missing" --run perl "$(top_srcdir)/build/gen-changelog.pl" ) > ChangeLog.tmp ) && \
		  mv -f ChangeLog.tmp "$(distdir)/synthesis/ChangeLog" || \
		  ( rm -f ChangeLog.tmp ; \
		     echo Failed to generate ChangeLog >&2 ) \
                ); \
	elif test $(SYNTHESIS_SRC) != "no-synthesis-source"; then \
		cp -a $(SYNTHESIS_SRC)/* $(distdir)/synthesis  && \
		for i in _build autom4te.cache; do [ ! -d "$(SYNTHESIS_SRC)/$$i" ] || chmod -R u+rwx "$(SYNTHESIS_SRC)/$$i"; done && \
		find "$(distdir)" -name .libs -o -name "*~" -o -name ".*" -o -name "*.o" -o -name "*.lo" -o -name CVS -o -name .svn -o -name .git -o -name autom4te.cache -print0 | xargs -0 rm -rf; \
	fi

clean-local: testclean
	rm -rf testcases
	[ ! -L templates ] || rm templates

# files created during testing
testclean:
	rm -rf *.test.vcf *.log *.tests *.diff *.dat *Client_Sync_*client.*

distclean-local:
	rm -rf $(SYNTHESIS_SUBDIR)
	rm -rf $(CLEAN_CLIENT_SRC)

if COND_DBUS
syncevo_dbus_server_SOURCES = \
	NotificationBackendBase.h \
	NotificationBackendNoop.h \
	NotificationBackendNoop.cpp \
	NotificationBackendLibnotify.h \
	NotificationBackendLibnotify.cpp \
	NotificationBackendMLite.h \
	NotificationBackendMLite.cpp \
	NotificationManager.h \
	NotificationManagerBase.h \
	NotificationManagerFactory.h \
	NotificationManagerFactory.cpp \
	syncevo-dbus-server.cpp \
	$(CORE_SOURCES)
if ENABLE_UNIT_TESTS
nodist_syncevo_dbus_server_SOURCES = ../test/test.cpp
endif

syncevo_dbus_server_LDADD = gdbus/libgdbussyncevo.la $(CORE_LDADD) $(KEYRING_LIBS) $(LIBNOTIFY_LIBS) $(MLITE_LIBS) $(KDE_KWALLET_LIBS) $(DBUS_LIBS)
syncevo_dbus_server_CPPFLAGS = -DHAVE_CONFIG_H -I$(srcdir)/gdbus $(AM_CPPFLAGS) -DSYNCEVOLUTION_LOCALEDIR=\"${SYNCEVOLUTION_LOCALEDIR}\"
syncevo_dbus_server_CXXFLAGS = $(SYNCEVOLUTION_CXXFLAGS) $(CORE_CXXFLAGS) $(GLIB_CFLAGS) $(DBUS_CFLAGS) $(LIBSOUP_CFLAGS) $(KEYRING_CFLAGS) $(LIBNOTIFY_CFLAGS) $(MLITE_CFLAGS) $(KDE_KWALLET_CFLAGS)
syncevo_dbus_server_LDFLAGS = $(CORE_LD_FLAGS) $(LIBSOUP_LIBS)
syncevo_dbus_server_DEPENDENCIES = gdbus/libgdbussyncevo.la $(EXTRA_LTLIBRARIES) $(CORE_DEP) $(SYNTHESIS_DEP)
endif

# With --disable-shared autotools links against libfunambol.a which does not
# pull any of the test suites into the test binary, so they would not be
# executed. The workaround is to explicitly set them as undefined on the
# link line.
client_test_SOURCES = \
	client-test-app.cpp \
	CmdlineSyncClient.cpp \
	../test/ClientTest.cpp \
	../test/ClientTest.h \
	../test/client-test-main.cpp \
	$(CORE_SOURCES)
nodist_client_test_SOURCES = ../test/test.cpp

if ENABLE_BUTEO_TESTS
client_test_SOURCES += client-test-buteo.h
client_test_SOURCES += client-test-buteo.cpp
nodist_client_test_SOURCES += client-test-buteo.moc.cpp
endif

# list of test file base files
#
# Generated files (testcases/eds_event.ics.funambol.tem) are derived from
# the original base file ($(srcdir)/test/testcases/eds_event.ics) by
# applying a patch ($(srcdir)/test/testcases/eds_event.ics.funambol.tem.patch).
CLIENT_LIB_TEST_FILES = \
	testcases/lcs/file1.txt \
	testcases/lcs/file2.txt \
        testcases/local.png \
	testcases/templates/clients/SyncEvolution.ini \
	testcases/templates/clients/phone/nokia/S40/7210c.ini \
	testcases/google_event.ics \
	testcases/yahoo_contact.vcf \
	testcases/eds_contact.vcf \
	testcases/eds_event.ics \
	testcases/eds_event.ics.local \
	testcases/eds_memo.ics \
	testcases/eds_task.ics

# all patch files
TEST_FILES_PATCHES = $(wildcard $(srcdir)/../test/testcases/*.patch)
# generated local files
TEST_FILES_GENERATED = $(subst .patch,,$(subst $(srcdir)/../test/,,$(TEST_FILES_PATCHES)))
# all patched files, regardless whether the patch already exists
TEST_FILES_PATCHED = $(wildcard testcases/*.tem)
# add files created via patches
CLIENT_LIB_TEST_FILES += $(TEST_FILES_GENERATED)

client_test_CPPFLAGS = -DHAVE_CONFIG_H -DENABLE_INTEGRATION_TESTS -DENABLE_UNIT_TESTS $(AM_CPPFLAGS) $(BUTEOSYNCPROFILE_CFLAGS) $(BUTEOSYNCCOMMON_CFLAGS) $(QT_CPPFLAGS)
client_test_CXXFLAGS = `cppunit-config --cflags` $(SYNCEVOLUTION_CXXFLAGS) $(CORE_CXXFLAGS) $(KEYRING_CFLAGS) $(BUTEOSYNCPROFILE_CFLAGS) $(BUTEOSYNCCOMMON_CFLAGS) $(filter-out -O2 -g -W -Wall, $(QT_CXXFLAGS))
client_test_LDFLAGS = `cppunit-config --libs` `nm syncevo/.libs/libsyncevolution.a | grep funambolAutoRegisterRegistry | sed -e 's/.* /-Wl,-u/'` $(CORE_LD_FLAGS) $(KEYRING_LIBS) $(BUTEOSYNCPROFILE_LIBS) $(BUTEOSYNCCOMMON_LIBS) $(QT_LDFLAGS)
client_test_LDADD = $(CORE_LDADD) $(SYNTHESIS_ENGINE) $(BUTEOSYNCPROFILE_LIBS) $(BUTEOSYNCCOMMON_LIBS) $(QT_LIBS)
# These dependencies are intentionally a bit too broad:
# they ensure that all files are in place to *run* client-test.

# rule to generate patched files from patches:
# make cannot compute the dependencies completely, so run the commands
# on each make invocation and do the time stamp test ourselves
#
# If we create the patched file anew, then set its time to the more
# recent of the two input files. That way it won't be re-generated
# (because it is not older), and it won't be used to refresh the patch
# either in testcase2patch (because it is not newer either).
# That is useful on platforms where diff produces different results
# than the one in the source (possible because the "find shortest
# patch" problem may have multiple solutions).
.PHONY: $(TEST_FILES_GENERATED)
$(TEST_FILES_GENERATED):
	@ mkdir -p testcases
	@ echo "checking whether server specific test case $@ is up-to-date"
	@ set -e; \
	patchfile=$(srcdir)/../test/$@.patch; \
	basefile=$(srcdir)/../test/$(basename $(basename $@)); \
	( [ -e $@ ] && [ ! $@ -ot $$patchfile ] && [ ! $@ -ot $$basefile ] && echo "   $@ up-to-date" ) || \
	( [ ! -s $$patchfile ] && echo "   copy $$basefile to $@ because patch file is empty" && cp $$basefile $@ ) || \
	( echo "   generating $@ by applying $$patchfile to $$basefile" && \
	  (echo '*** foo'; echo '--- bar'; cat $$patchfile) | patch -s -o $@ $$basefile && \
          ( if [ $$basefile -ot $$patchfile ]; then \
              touch -r $$patchfile $@; else \
              touch -r $$basefile $@; fi ) \
        )


# rule to regenerate patches:
# like generating the patched files, this is run every time.
# It must avoid making the patch file more recent than the
# patched file, otherwise the rule above would needlessly recreate
# it (not nice when having the file open in an editor).
#
# To avoid needlessly updating the content of the patch file,
# the first two lines with changing information (paths, file dates)
# are stripped from it.
.PHONY: testcase2patch
testcase2patch: $(TEST_FILES_GENERATED)
	@ echo "checking whether test case patch files are up-to-date"
	@ set -e; \
	for i in testcases/*.tem; do \
		patchfile=$(srcdir)/../test/$$i.patch; \
		basefile=$(srcdir)/../test/`echo $$i | cut -d . -f  -2`; \
		if [ $$patchfile -ot $$i ] || [ $$patchfile -ot $$basefile ]; then \
			diff -u $$basefile $$i | tail -n +3 > $$patchfile || true; \
			touch -r $$i $$patchfile; \
			echo "   updated $$patchfile"; \
                else \
                        echo "   $$patchfile up-to-date"; \
		fi; \
	done

# copy base test files
$(filter-out %.tem, $(filter testcases/%, $(subst $(srcdir)/../test/,,$(CLIENT_LIB_TEST_FILES)))) : % : $(srcdir)/../test/%
	mkdir -p ${@D}
	cp $< $@

# The binary does not really depend on the test cases, only running it does.
# Listing the dependencies here is done to ensure that one doesn't accidentally
# runs the binary with out-dated auxiliary files.
client_test_DEPENDENCIES = $(EXTRA_LTLIBRARIES) $(CORE_DEP) $(CLIENT_LIB_TEST_FILES) testcase2patch synccompare templates

CLEANFILES += client-test-buteo.moc.cpp

# copy template directory into current working directory, if not there
# yet
.PHONY: templates
templates:
	if test "$(srcdir)/templates" != "./templates"; then \
		rm -rf ./templates; \
		ln -s "$(srcdir)/templates" .; \
	fi

# distribute test system?
if ENABLE_TESTING
# yes: install client-test in bindir, test files in datadir
TESTS += client-test
bin_PROGRAMS += client-test
nobase_dist_doc_DATA = $(CLIENT_LIB_TEST_FILES)
else
# The "all" dependency causes a rebuild even if the actual input files
# haven't changed. If client-test is part of the regular targets built
# by "all", then it must not depend on all!
EXTRA_PROGRAMS += client-test
nodist_client_test_SOURCES += $(CLIENT_LIB_TEST_FILES)
client_test_DEPENDENCIES += all
endif

# test program for output redirection, has to be built
# and run manually
EXTRA_PROGRAMS += abort-redirect
CLEANFILES += abort-redirect.log
abort_redirect_SOURCES = ../test/abort-redirect.cpp
abort_redirect_CPPFLAGS = -DHAVE_CONFIG_H $(AM_CPPFLAGS)
abort_redirect_CXXFLAGS = $(SYNCEVOLUTION_CXXFLAGS) $(CORE_CXXFLAGS)
abort_redirect_LDFLAGS = $(CORE_LD_FLAGS)
abort_redirect_LDADD = $(CORE_LDADD)
abort_redirect_DEPENDENCIES = all


# special target for testing with valgrind
valgrind : test
	valgrind --leak-check=yes --suppressions=valgrind.supp ./client-test

# Same solution for rebuilding as in top-level Makefile, see there
# for further comments.
$(srcdir)/Makefile.am: check-autotools
	@ true
.PHONY: check-autotools
check-autotools:
	@ cd $(top_srcdir) && ( [ ! -e .git ] || ./gen-autotools.sh )

# old-style name for test program(s)
.PHONY: test
test: client-test
