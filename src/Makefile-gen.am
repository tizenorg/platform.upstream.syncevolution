BACKENDS = @BACKENDS@

service_in_files = org.syncevolution.service.in
if COND_DBUS
servicedir = $(DBUS_SERVICES_DIR)
service_DATA = $(service_in_files:.service.in=.service)
$(service_DATA): $(service_in_files) Makefile
	@sed -e "s|\@libexecdir\@|$(libexecdir)|" $< > $@

DBUS_DIRS = gdbus dbus
else
if COND_GUI
# jump into interface directory directly instead of going through dbus
DBUS_DIRS = dbus/interfaces
endif
endif

if COND_GUI
GUI_DIR = gtk-ui
endif

SUBDIRS = $(SYNTHESIS_SUBDIR) $(DBUS_DIRS) syncevo $(BACKENDS) $(GUI_DIR)
DIST_SUBDIRS = gdbus dbus syncevo $(BACKENDS) gtk-ui
BUILT_SOURCES =

AM_CPPFLAGS = $(SUBDIRS:%=-I$(srcdir)/%) -I$(srcdir)/../test -I$(top_srcdir) $(BACKEND_CPPFLAGS) $(GLIB_CFLAGS)

EXTRA_PROGRAMS =
TESTS =
bin_PROGRAMS = syncevolution
if COND_DBUS
libexec_PROGRAMS = syncevo-dbus-server
endif

bin_SCRIPTS = synccompare
SYNCEVOLUTION_DEP =
if ENABLE_MODULES
else
SYNCEVOLUTION_LDADD += $(SYNCSOURCES)
SYNCEVOLUTION_DEP += $(SYNCSOURCES)
endif
EXTRA_DIST = shlibs.local Makefile-gen.am syncclient_sample_config.xml $(service_in_files)

TEMPLATE_FILES = @TEMPLATE_FILES@
templatedir = $(datadir)/syncevolution/
nobase_dist_template_DATA = $(TEMPLATE_FILES)

DISTCLEANFILES = synccompare
MAINTAINERCLEANFILES = Makefile.in
CLEANFILES = libstdc++.a client-test $(CLIENT_LIB_TEST_FILES) \
	org.syncevolution.service

# synccompare is created by replacing its 'import Algorithm::Diff;'
# with a simplified copy of Diff.pm.
synccompare : ../test/Algorithm/Diff.pm ../test/synccompare.pl
	perl -e '$$diff = shift; open(DIFF, "<$$diff"); ($$_) = split(/__END__/, join("", <DIFF>)); s/\*import.*//m; s/require +Exporter;//; s/^#.*\n//mg; s/ +#.*\n//mg; $$diff = $$_;' -e 'while(<>) {' @MODIFY_SYNCCOMPARE@ -e 's/use +Algorithm::Diff;/"# embedded version of Algorithm::Diff follows, copyright by the original authors\n" . $$diff . "# end of embedded Algorithm::Diff\n"/e; print;}' $+ >$@
	chmod u+x $@

CORE_SOURCES =

# The files which register backends have to be compiled into
# "client-test" and "syncevolution" in order to pull in the
# code from the libs which implement the backends.
#
# Unit testing also goes there.
#
# When using modules the registration is done inside the
# module and the register file is unnecessary. However, they
# still need to be included in "make dist".
BACKEND_REGISTRIES = @BACKEND_REGISTRIES@
if ENABLE_MODULES
EXTRA_DIST += $(BACKEND_REGISTRIES)
else
CORE_SOURCES += $(BACKEND_REGISTRIES)
endif

CORE_CXXFLAGS = $(SYNTHESIS_CFLAGS)
CORE_LDADD = $(SYNCEVOLUTION_LDADD) syncevo/libsyncevolution.la $(GLIB_LIBS) $(LIBS)
CORE_DEP = $(SYNCEVOLUTION_DEP) syncevo/libsyncevolution.la $(SYNTHESIS_DEP)
CORE_LD_FLAGS = -uSyncEvolution_Module_Version -Wl,--export-dynamic

# put link to static c++ library into current directory, needed if compiling with --enable-static-c++
libstdc++.a :
	path=`$(CXX) $(CORE_LDADD) $(LD_FLAGS) -print-file-name=libstdc++.a` && ln -s $$path .

syncevolution_SOURCES = \
	syncevolution.cpp \
	CmdlineSyncClient.h \
	CmdlineSyncClient.cpp \
	$(CORE_SOURCES)
nodist_syncevolution_SOURCES = ../test/test.cpp

# SYNCEVOLUTION_LDADD will be replaced with libsyncebook.la/libsyncecal.la/libsyncsqlite.la
# if linking statically against them, empty otherwise;
# either way this does not lead to a dependency on those libs - done explicitly
syncevolution_LDADD = $(CORE_LDADD) $(KEYRING_LIBS)
syncevolution_LDFLAGS = $(CORE_LD_FLAGS)
syncevolution_CXXFLAGS = $(SYNCEVOLUTION_CXXFLAGS) $(CORE_CXXFLAGS) $(KEYRING_CFLAGS)
syncevolution_DEPENDENCIES = $(EXTRA_LTLIBRARIES) $(CORE_DEP) # $(SYNTHESIS_DEP)

# rule which is only relevant when compiling Synthesis in subdirectory
#$(SYNTHESIS_LIB) : $(SYNTHESIS_SUBDIR)/all
#$(SYNTHESIS_SUBDIR)/% :
#	[ ! "$(SYNTHESIS_SUBDIR)" ] || ( cd ${@D} && $(MAKE) ${@F} )

# include Synthesis in distribution: package only files in git if using a git checkout
dist-hook:
	set -x; [ ! "$(SYNTHESIS_SUBDIR)" ] || \
	mkdir -p $(distdir)/synthesis && \
	if test -d "$(SYNTHESIS_SRC)/.git"; \
	then \
		( ( cd "$(SYNTHESIS_SRC)" && git archive HEAD ) | ( cd "$(distdir)/synthesis" && tar xf - && $$SHELL autogen.sh && rm -rf autom4te.cache ) ) && \
		( echo Creating ChangeLog && \
		  ( ( cd "$(SYNTHESIS_SRC)" && \
		      echo '# Generated by configure.  Do no edit.' && \
		      githash=`git show-ref --head --hash | head -1` && \
		      echo "# git revision $$githash"  && \
		      echo "# git tag `git describe --tags $$githash`" && \
		      echo && \
		      "$(top_srcdir)/missing" --run perl "$(top_srcdir)/build/gen-changelog.pl" ) > ChangeLog.tmp ) && \
		  mv -f ChangeLog.tmp "$(distdir)/synthesis/ChangeLog" || \
		  ( rm -f ChangeLog.tmp ; \
		     echo Failed to generate ChangeLog >&2 ) \
                ); \
	elif test $(SYNTHESIS_SRC) != "no-synthesis-source"; then \
		cp -a $(SYNTHESIS_SRC)/* $(distdir)/synthesis  && \
		for i in _build autom4te.cache; do [ ! -d "$(SYNTHESIS_SRC)/$$i" ] || chmod -R u+rwx "$(SYNTHESIS_SRC)/$$i"; done && \
		find "$(distdir)" -name .libs -o -name "*~" -o -name ".*" -o -name "*.o" -o -name "*.lo" -o -name CVS -o -name .svn -o -name .git -o -name autom4te.cache -print0 | xargs -0 rm -rf; \
	fi

clean-local: testclean
	rm -rf testcases

# files created during testing
testclean:
	rm -rf *.test.vcf *.log *.tests *.diff *.dat *Client_Sync_*client.*

distclean-local:
	rm -rf $(SYNTHESIS_SUBDIR)
	rm -rf $(CLEAN_CLIENT_SRC)

if COND_DBUS
syncevo_dbus_server_SOURCES = \
	syncevo-dbus-server.cpp \
	$(CORE_SOURCES)
nodist_syncevo_dbus_server_SOURCES = \
	../test/test.cpp

syncevo_dbus_server_LDADD = gdbus/libgdbus.la $(CORE_LDADD)
syncevo_dbus_server_CPPFLAGS = -DHAVE_CONFIG_H -I$(srcdir)/gdbus $(AM_CPPFLAGS)
syncevo_dbus_server_CXXFLAGS = $(SYNCEVOLUTION_CXXFLAGS) $(CORE_CXXFLAGS) $(GLIB_CFLAGS) $(DBUS_CFLAGS) $(LIBSOUP_CFLAGS)
syncevo_dbus_server_LDFLAGS = $(CORE_LD_FLAGS) $(LIBSOUP_LIBS)
syncevo_dbus_server_DEPENDENCIES = gdbus/libgdbus.la $(EXTRA_LTLIBRARIES) $(CORE_DEP) $(SYNTHESIS_DEP)
endif

# With --disable-shared autotools links against libfunambol.a which does not
# pull any of the test suites into the test binary, so they would not be
# executed. The workaround is to explicitly set them as undefined on the
# link line.
client_test_SOURCES = \
	client-test-app.cpp \
	../test/ClientTest.cpp \
	../test/ClientTest.h \
	../test/client-test-main.cpp \
	$(CORE_SOURCES)
nodist_client_test_SOURCES = ../test/test.cpp

# Always compile the registry files into client-test because that is
# the only place where they are compiled with
# ENABLE_INTEGRATION_TESTS.  This works without undefined references
# because client-test is linked against all shared backend libraries
# (non-portable, but works).
# Disabled now, the client test can also be dynamically loaded and registered
# just the same as syncevolution
# if ENABLE_MODULES
# client_test_SOURCES += $(BACKEND_REGISTRIES)
# endif

# list of test file base files
#
# Generated files (testcases/ical20.ics.funambol.tem) are derived from
# the original base file ($(srcdir)/test/testcases/ical20.ics) by
# applying a patch ($(srcdir)/test/testcases/ical20.ics.funambol.tem.patch).
CLIENT_LIB_TEST_FILES = \
	testcases/vcard21.vcf \
	testcases/vcard30.vcf \
	testcases/ical20.ics \
	testcases/imemo20.ics \
	testcases/itodo20.ics

# all patch files
TEST_FILES_PATCHES = $(wildcard $(srcdir)/../test/testcases/*.patch)
# generated local files
TEST_FILES_GENERATED = $(subst .patch,,$(subst $(srcdir)/../test/,,$(TEST_FILES_PATCHES)))
# all patched files, regardless whether the patch already exists
TEST_FILES_PATCHED = $(wildcard testcases/*.tem)
# add files created via patches
CLIENT_LIB_TEST_FILES += $(TEST_FILES_GENERATED)

client_test_CPPFLAGS = -DHAVE_CONFIG_H -DENABLE_INTEGRATION_TESTS -DENABLE_UNIT_TESTS $(AM_CPPFLAGS)
client_test_CXXFLAGS = `cppunit-config --cflags` $(SYNCEVOLUTION_CXXFLAGS) $(CORE_CXXFLAGS)
client_test_LDFLAGS = `cppunit-config --libs` `nm syncevo/.libs/libsyncevolution.a | grep funambolAutoRegisterRegistry | sed -e 's/.* /-u /'` $(CORE_LD_FLAGS)
client_test_LDADD = $(CORE_LDADD) $(SYNTHESIS_ENGINE)
# These dependencies are intentionally a bit too broad:
# they ensure that all files are in place to *run* client-test.

# rule to generate patched files from patches:
# make cannot compute the dependencies completely, so run the commands
# on each make invocation and do the time stamp test ourselves
.PHONY: $(TEST_FILES_GENERATED)
$(TEST_FILES_GENERATED):
	@ mkdir -p testcases
	@ echo "checking whether server specific test cases $@ are up-to-date"
	set -e; \
	patchfile=$(srcdir)/../test/$@.patch; \
	basefile=$(srcdir)/../test/$(basename $(basename $@)); \
	[ ! $@ -ot $$patchfile ] && [ ! $@ -ot $$basefile ] || \
	(echo '*** foo'; echo '--- bar'; cat $$patchfile) | patch -o $@ $$basefile

# rule to regenerate patches:
# like generating the patched files, this is run every time.
# It must avoid making the patch file more recent than the
# patched file, otherwise the rule above would needlessly recreate
# it (not nice when having the file open in an editor).
#
# To avoid needlessly updating the content of the patch file,
# the first two lines with changing information (paths, file dates)
# are stripped from it.
.PHONY: testcase2patch
testcase2patch: $(TEST_FILES_GENERATED)
	@ echo "checking whether test case patch files are up-to-date"
	set -e; \
	for i in testcases/*.tem; do \
		patchfile=$(srcdir)/../test/$$i.patch; \
		basefile=$(srcdir)/../test/`echo $$i | cut -d . -f  -2`; \
		if [ $$patchfile -ot $$i ] || [ $$patchfile -ot $$basefile ]; then \
			diff -u $$basefile $$i | tail -n +3 > $$patchfile || true; \
			touch -r $$i $$patchfile; \
			echo "updated $$patchfile"; \
		fi; \
	done

# copy base test files
$(filter-out %.tem, $(filter testcases/%, $(subst $(srcdir)/../test/,,$(CLIENT_LIB_TEST_FILES)))) : % : $(srcdir)/../test/%
	mkdir -p testcases
	cp $< $@

# The binary does not really depend on the test cases, only running it does.
# Listing the dependencies here is done to ensure that one doesn't accidentally
# runs the binary with out-dated auxiliary files.
client_test_DEPENDENCIES = $(EXTRA_LTLIBRARIES) $(CORE_DEP) $(CLIENT_LIB_TEST_FILES) testcase2patch synccompare templates

# copy template directory into current working directory, if not there
# yet
.PHONY: templates
templates:
	if test "$(srcdir)/templates" != "./templates"; then \
		rm -rf ./templates; \
		cp -r "$(srcdir)/templates" .; \
	fi

# distribute test system?
if ENABLE_TESTING
# yes: install client-test in bindir, test files in datadir
TESTS += client-test
bin_PROGRAMS += client-test
nobase_dist_doc_DATA = $(CLIENT_LIB_TEST_FILES)
else
# The "all" dependency causes a rebuild even if the actual input files
# haven't changed. If client-test is part of the regular targets built
# by "all", then it must not depend on all!
EXTRA_PROGRAMS += client-test
nodist_client_test_SOURCES += $(CLIENT_LIB_TEST_FILES)
client_test_DEPENDENCIES += all
endif

# test program for output redirection, has to be built
# and run manually
EXTRA_PROGRAMS += abort-redirect
CLEANFILES += abort-redirect.log
abort_redirect_SOURCES = ../test/abort-redirect.cpp
abort_redirect_CPPFLAGS = -DHAVE_CONFIG_H $(AM_CPPFLAGS)
abort_redirect_CXXFLAGS = $(SYNCEVOLUTION_CXXFLAGS) $(CORE_CXXFLAGS)
abort_redirect_LDFLAGS = $(CORE_LD_FLAGS)
abort_redirect_LDADD = $(CORE_LDADD)
abort_redirect_DEPENDENCIES = all


# special target for testing with valgrind
valgrind : test
	valgrind --leak-check=yes --suppressions=valgrind.supp ./test

# Because backend-related variables need to be substituted in
# Makefile-gen.am we need an explicit rule to redo that work
# so that "make" rebuilds derived files correctly.
$(srcdir)/Makefile.am: Makefile-gen.am
	sed -e 's;[@]BACKEND_REGISTRIES[@];$(BACKEND_REGISTRIES);' \
	    -e 's;[@]BACKENDS[@];$(BACKENDS);' \
            -e 's;[@]TEMPLATE_FILES[@];$(TEMPLATE_FILES);' \
	    $< >$@

# old-style name for test program(s)
.PHONY: test
test: client-test
